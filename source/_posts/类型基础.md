---
title: 类型基础
date: 2019-03-26 21:26:08
categories: C# 
tags: 
 - 基础
 - C#
---
### 所有类型都从System.Object 派生
#### System.Object 公共实例方法
| 公共方法 | 说明 |
| :------: | :------: |
| Equals | 判断两个对象是否具有相同的值 |
| GetHashCode | 返回对象的值的哈希码 |
| ToString | 默认返回类型的完整名称,常被重写用于返回对象状态表示的String对象 |
| ToString | 返回调用对象的确切类型 |
<!--more-->
#### 所有对象都用new操作符创建,delete操作符显式释放为对象分配的内存
```cs
Blog b = new Blog();
```
new操作所做的事情
* 计算类型及所有基类型中定义的所有实例字段需要的字节数
* 从托管堆中分配类型要求的字节数,从而分配对象的内存,分配的所有字节都设为0
* 初始化对象的"类型对象指针"和"同步块索引"成员
* 调用类型的实例构造器(构造函数)

## 类型转换
### 基类与派生类之间的转换
* 将对象转换为它的任何基类型都不要求任何特殊语法
* 将对象转换为它的某个派生类型时,需要进行显示转换
```cs
Object o = new Blog();
Blog b = (Blog) o;
```
### is和as操作符来转型
#### is操作符
* is操作符检查对象是否兼容于指定类型,返回true或false(永不抛出异常)
* 如果对象引用null,is操作符总是返回false
* 使用如下
    ```cs
    if(o is Blog)
    {
        Blog b = (Blog) o;
    }
    ```
* PS：使用is操作符,实际上会检查两次对象类型,先核实是否兼容于Blog类型,if内部转型时,会再次核实o是否引用一个Blog类型
#### as操作符
* as操作符用于核实对象是否兼容于指定类型,返回对同一对象的非null引用和null(永不抛出异常)
* 使用如下
    ```cs
    Blog b = o as Blog;
    if(e != null)
    {
        //
    }
    ```
* PS：使用as操作符,只校验一次对象类型

### 调用静态方法,实例方法和虚方法的区别
#### 调用静态方法
调用静态方式时,CLR会定位与定义静态方法的类型对应的类型对象,然后JIT编译器在类型对象的方法表中查找与被调用方法对应的记录项,对方法进行JIT编译,再调用JIT编译好的代码.
#### 调用实例方法
调用实例方法时,JIT编译器会找到与"发出调用的那个变量的类型"对应的类型对象.如果对应的类型对象没有定义正在调用的那个方法,JIT编译器会回溯类层次结构(一直回溯到Object),并在沿途的每个类型中查找该方法.然后JIT编译器在类型对象的方法表中查找与被调用方法对应的记录项,对方法进行JIT编译,再调用JIT编译好的代码.
#### 调用虚方法
调用虚方法时,JIT编译器要在方法中生成一些额外的代码;方法每次调用都会执行这些代码.这些代码首先会检查发出调用的变量,并跟随地址来到发出调用的对象.然后代码检查对象内部的"类型对象指针"成员,该成员指向对象的实际类型.然后,代码在类型对象的方法表中查找与被调用方法对应的记录项,对方法进行JIT编译,再调用JIT编译好的代码.

